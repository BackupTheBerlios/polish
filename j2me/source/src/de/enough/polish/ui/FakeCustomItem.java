//#condition polish.LibraryBuild
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
/*
 * Copyright (c) 2003, 2004 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with J2ME Polish; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
package de.enough.polish.ui;

import java.io.IOException;

import javax.microedition.lcdui.Canvas;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;
//#if polish.blackberry
	import net.rim.device.api.ui.Field;
//#endif

import de.enough.polish.util.ArrayList;
import de.enough.polish.util.HashMap;


/**
 * Meant for classes that want to be compatible with javax.microedition.lcdui.CustomItem for IDEs only while extending de.enough.polish.ui.Item in reality.
 * <p>Subclasses can change the hierarchy with preprocessing like this:
 * <pre>
 * public class MyCustomItem
 * //#if polish.LibraryBuild
 * 		 extends FakeCustomItem
 * //#else
 * 		//# extends Item
 * //#endif	 
 * </pre>
 * </p>
 * <p>This allows subclasses to access all fields and methods of the J2ME Polish item class.</p>
 * <p>Note that this class can never be used in reality. Ever.</p>
 * 
 * @since J2ME Polish 1.3
 * @author Robert Virkus, robert@enough.de
 * @see Item
 */
public abstract class FakeCustomItem extends javax.microedition.lcdui.CustomItem
{
	

	////////////////////////////  DEFAULT IMPLEMENTATION OF ABSTRACT CUSTOM ITEM METHODS ///////////////
	/**
	 * Default implementation of javax.microedition.lcdui.CustomItem method.
	 * 
	 * @return the minimum content width in pixels
	 */
	protected final int getMinContentWidth() {
		return this.contentWidth;		
	}

	/**
	 * Default implementation of javax.microedition.lcdui.CustomItem method.
	 * 
	 * @return the minimum content height in pixels
	 */
	protected final int getMinContentHeight() {
		return this.contentHeight;
	}

	/**
	 * Default implementation of javax.microedition.lcdui.CustomItem method.
	 * 
	 * @param height the tentative content height in pixels, or -1 if a tentative height has not been computed.
	 * 			J2ME Polish will always specify -1 as the height.
	 * @return the preferred content width in pixels
	 */
	protected final  int getPrefContentWidth(int height) {
		return this.contentWidth;
	}

	/**
	 * Default implementation of javax.microedition.lcdui.CustomItem method.
	 * 
	 * @param width the tentative content width in pixels, or -1 if a tentative width has not been computed
	 * @return the preferred content height in pixels
	 */
	protected final int getPrefContentHeight(int width) {
		return this.contentWidth;
	}
	/**
	 * Default implementation of javax.microedition.lcdui.CustomItem method.
	 * 
	 * @param g the Graphics object to be used for rendering the item
	 * @param w current width of the item in pixels
	 * @param h current height of the item in pixels
	 */
	protected final void paint( Graphics g, int w, int h) {
		// ignore
	}

	
	//////////////  END DEFAULT IMPLEMENTATION OF CUSTOM ITEM METHODS  /////////////////////////////

	
	/**
	 * A J2ME Polish constant defining a transparent/invisible color.
	 * TRANSPARENT has the value -1.
	 */
	public static final int TRANSPARENT = -1;
	
	/**
	 * A J2ME Polish constant defining a vertical orientation.
	 * VERTICAL has the value 0.
	 */
	public static final int VERTICAL = 0;
	
	/**
	 * A J2ME Polish constant defining a horizontal orientation.
	 * HORIZONTAL has the value 1.
	 */
	public static final int HORIZONTAL = 1;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should follow the default layout policy of its container.
	 * 
	 * <P>Value <code>0</code> is assigned to <code>LAYOUT_DEFAULT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_DEFAULT = 0;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * left-aligned layout.
	 * 
	 * <P>Value <code>1</code> is assigned to <code>LAYOUT_LEFT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_LEFT = 1;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * right-aligned layout.
	 * 
	 * <P>Value <code>2</code> is assigned to <code>LAYOUT_RIGHT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_RIGHT = 2;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * horizontally centered layout.
	 * 
	 * <P>Value <code>3</code> is assigned to <code>LAYOUT_CENTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_CENTER = 3;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * top-aligned layout.
	 * 
	 * <P>Value <code>0x10</code> is assigned to <code>LAYOUT_TOP</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_TOP = 0x10;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * bottom-aligned layout.
	 * 
	 * <P>Value <code>0x20</code> is assigned to <code>LAYOUT_BOTTOM</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_BOTTOM = 0x20;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * vertically centered layout.
	 * 
	 * <P>Value <code>0x30</code> is assigned to
	 * <code>LAYOUT_VCENTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VCENTER = 0x30;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should be placed at the beginning of a new line or row.
	 * 
	 * <P>Value <code>0x100</code> is assigned to
	 * <code>LAYOUT_NEWLINE_BEFORE</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_NEWLINE_BEFORE = 0x100;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should the last on its line or row, and that the next
	 * <code>Item</code> (if any) in the container
	 * should be placed on a new line or row.
	 * 
	 * <P>Value <code>0x200</code> is assigned to
	 * <code>LAYOUT_NEWLINE_AFTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_NEWLINE_AFTER = 0x200;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * width may be reduced to its minimum width.
	 * 
	 * <P>Value <code>0x400</code> is assigned to <code>LAYOUT_SHRINK</code></P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_SHRINK = 0x400;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * width may be increased to fill available space.
	 * 
	 * <P>Value <code>0x800</code> is assigned to <code>LAYOUT_EXPAND</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_EXPAND = 0x800;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * height may be reduced to its minimum height.
	 * 
	 * <P>Value <code>0x1000</code> is assigned to
	 * <code>LAYOUT_VSHRINK</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VSHRINK = 0x1000;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * height may be increased to fill available space.
	 * 
	 * <P>Value <code>0x2000</code> is assigned to
	 * <code>LAYOUT_VEXPAND</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VEXPAND = 0x2000;

	/**
	 * A layout directive indicating that new MIDP 2.0 layout
	 * rules are in effect for this <code>Item</code>.  If this
	 * bit is clear, indicates that MIDP 1.0 layout behavior
	 * applies to this <code>Item</code>.
	 * 
	 * <P>Value <code>0x4000</code> is assigned to
	 * <code>LAYOUT_2</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_2 = 0x4000;

	/**
	 * An appearance mode value indicating that the <code>Item</code> is to have
	 * a normal appearance.
	 * 
	 * <P>Value <code>0</code> is assigned to <code>PLAIN</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int PLAIN = 0;

	/**
	 * An appearance mode value indicating that the <code>Item</code>
	 * is to appear as a hyperlink.
	 * <P>Value <code>1</code> is assigned to <code>HYPERLINK</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int HYPERLINK = 1;

	/**
	 * An appearance mode value indicating that the <code>Item</code>
	 * is to appear as a button.
	 * <P>Value <code>2</code> is assigned to <code>BUTTON</code>.</P>
	 * 
	 * @since MIDP 2.0
	 */
	public static final int BUTTON = 2;

	/**
	 * A J2ME Polish appearance mode value indicating that the <code>Item</code>
	 * accepts input from the user.
	 * <P>Value <code>3</code> is assigned to <code>INTERACTIVE</code>.</P>
	 */
	public static final int INTERACTIVE = 3;
	
	protected int layout;
	protected ItemCommandListener itemCommandListener;
	protected Command defaultCommand;
	protected int preferredWidth;
	protected int preferredHeight;
	protected int minimumWidth;
	protected int minimumHeight;
	//#ifdef polish.css.max-width
		protected int maximumWidth;
	//#endif
	//#ifdef polish.css.max-height
		protected int maximumHeight;
	//#endif
	protected boolean isInitialised;
	public Background background;
	protected Border border;
	protected Style style;
	public int itemWidth;
	public int itemHeight;
	protected int paddingLeft;
	protected int paddingTop;
	protected int paddingRight;
	protected int paddingBottom;
	protected int paddingVertical;
	protected int paddingHorizontal;
	protected int marginLeft;
	protected int marginTop;
	protected int marginRight;
	protected int marginBottom;
	/** The width of this item's content **/
	protected int contentWidth;
	/** The height of this item's content **/
	protected int contentHeight;
	protected int borderWidth;
	protected int backgroundWidth;
	protected int backgroundHeight;
	/** The appearance mode of this item, either PLAIN or one of the interactive modes BUTTON, HYPERLINK or INTERACTIVE. */
	public int appearanceMode;
	/**
	 * The screen to which this item belongs to.
	 */
	protected Screen screen;
	//#ifdef polish.useDynamicStyles
		/**
		 * The appropriate CSS selector of this item. 
		 * This is either the style's name or a selector
		 * depending on the state of this item. A StringItem
		 * can have the selector "p", "a" or "button", for example.
		 * This variable can only be used, when the proprocessing variable
		 * "polish.useDynamicStyles" is defined.
		 */
		protected String cssSelector;
	//#endif
	/**
	 * Determines whether the style has be dynamically assigned already.
	 */
	protected boolean isStyleInitialised;
	/**
	 * The parent of this item.
	 */
	protected Item parent;

	protected ArrayList commands;
	
	protected boolean isLayoutCenter;
	protected boolean isLayoutExpand;
	protected boolean isLayoutRight;
	// the current positions of this item:
	/** the horizontal start position relative to it's parent's item left content edge */
	protected int relativeX;
	/** the vertical start position of this item relative to it's parent item top content edge */
	public int relativeY; // relativ to parent item
	/** the horizontal position of this item's content relative to it's left edge */
	protected int contentX;
	/** the vertical position of this item's content relative to it's top edge */
	protected int contentY; // absolute top vertical position of the content 
	// the current positions of an internal element relative to the content origin 
	// which should be visible:
	/** 
	 * The internal horizontal position of this item's content relative to it's left edge. 
	 * When it is equal -9999 this item's internal position is not known.
	 * The internal position is useful for items that have a large content which
	 * needs to be scrolled, e.g. containers.  
	 */
	protected int internalX = -9999;
	/** the vertical position of this item's internal content relative to it's top edge */
	protected int internalY;
	/** The internal width of this item's content.  */
	protected int internalWidth;
	/** The internal height of this item's content.  */
	protected int internalHeight;
	public boolean isFocused;
	
	//#ifdef polish.css.before
		private String beforeUrl;
		private int beforeWidth;
		private int beforeHeight;
		private Image beforeImage;
	//#endif

	//#ifdef polish.css.after
		private String afterUrl;
		private int afterWidth;
		private int afterHeight;
		private Image afterImage;
	//#endif
	// label settings:
	protected Style labelStyle = StyleSheet.labelStyle;
	protected StringItem label;
	private boolean useSingleRow;
	//#if polish.blackberry
		public Field _bbField;
		public boolean _bbFieldAdded;
	//#endif
	protected Style focusedStyle;

	//#if polish.css.colspan
		protected int colSpan = 1;
	//#endif
	//#if polish.css.rowspan
		protected int rowSpan;
	//#endif
	//#if polish.css.include-label
		protected boolean includeLabel;
	//#endif
	/** The vertical offset for the background, can be used for smoother scrolling, for example */ 
	protected int backgroundYOffset;

	private HashMap attributes;

	//#ifdef polish.css.view-type
		protected ItemView view;
	//#endif

	
	protected FakeCustomItem() {
		this( null, LAYOUT_DEFAULT, PLAIN, null );
	}
	
	protected FakeCustomItem( Style style ) {
		this( null, LAYOUT_DEFAULT, PLAIN, style );
	}
	
	protected FakeCustomItem( String label, int layout) {
		this( label, layout, PLAIN, null );
	}

	/**
	 * Creates a new Item.
	 * 
	 * @param label the label of this item
	 * @param layout the layout of this item
	 * @param appearanceMode the mode of this item, either Item.PLAIN, Item.BUTTON or Item.HYPERLINK
	 * @param style the style of this item - contains the background, border etc.
	 */
	protected FakeCustomItem(String label, int layout, int appearanceMode, Style style) {
		super( label );
		this.style = style;
		this.layout = layout;
		this.appearanceMode = appearanceMode;
		if (label != null && label.length() != 0) {
			setLabel( label );
		}
		if (style == null) {
			this.layout = layout;
		} else {
			this.style = style;
			this.isStyleInitialised = false;
		}
	}

	/**
	 * Sets the label of the <code>Item</code>. If <code>label</code>
	 * is <code>null</code>, specifies that this item has no label.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param label - the label string
	 * @throws IllegalStateException - if this Item is contained  within an Alert
	 * @see #getLabel()
	 */
	public void setLabel( String label)
	{
		if (this.label == null) {
			this.label = new StringItem( null, label, this.labelStyle );
			this.label.parent = this.parent;
		} else {
			this.label.setText( label );
		}
		if (this.isInitialised) {
			this.isInitialised = false;
			repaint();
		}
	}

	/**
	 * Gets the label of this <code>Item</code> object.
	 * 
	 * @return the label string
	 * @see #setLabel(java.lang.String)
	 */
	public String getLabel()
	{
		if (this.label == null) {
			return null;
		} else {
			return this.label.getText();
		}
	}
	
	/**
	 * Retrieves the label item that is used by this item.\
	 * 
	 * @return the item or null when no item is used.
	 */
	public Item getLabelItem() {
		return this.label;
	}

	/**
	 * Gets the layout directives used for placing the item.
	 * 
	 * @return a combination of layout directive values
	 * @see #setLayout(int)
	 * @since  MIDP 2.0
	 */
	public int getLayout()
	{
		return this.layout;
	}

	/**
	 * Sets the layout directives for this item.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param layout - a combination of layout directive values for this item
	 * @throws IllegalArgumentException - if the value of layout is not a bit-wise OR combination of layout directives
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @see #getLayout()
	 * @since  MIDP 2.0
	 */
	public void setLayout(int layout)
	{
		this.layout = layout;
	}

	/**
	 * Returns the appearance mode of this <code>Item</code>.
	 * See <a href="Item.html#appearance">Appearance Modes</a>.
	 * 
	 * @return the appearance mode value, one of Item.PLAIN, Item.HYPERLINK, or Item.BUTTON
	 * @since  MIDP 2.0
	 */
	public int getAppearanceMode()
	{
		return this.appearanceMode;
	}
	
	/**
	 * Sets the appearance mode of this item.
	 * 
	 * @param appearanceMode the mode value, one of Item.PLAIN, Item.HYPERLINK, or Item.BUTTON
	 */
	public void setAppearanceMode( int appearanceMode ) {
		this.appearanceMode = appearanceMode;
	}
	
	/**
	 * Retrieves the style of this item.
	 * 
	 * @return the style of this item.
	 */
	public Style getStyle() {
		return this.style;
	}
	
	/**
	 * Sets the style of this item.
	 * 
	 * @param style the new style for this item.
	 * @throws NullPointerException when style is null
	 */
	public void setStyle( Style style ) {
		//#debug
		System.out.println("setting style - with background: " + (style.background != null));
		this.isInitialised = false;
		this.isStyleInitialised = true;
		this.style = style;
		if (style != StyleSheet.defaultStyle) {
			this.layout = style.layout;
		}
		// horizontal styles: center -> right -> left
		if ( ( this.layout & LAYOUT_CENTER ) == LAYOUT_CENTER ) {
			this.isLayoutCenter = true;
			this.isLayoutRight = false;
		} else {
			this.isLayoutCenter = false;
			if ( ( this.layout & LAYOUT_RIGHT ) == LAYOUT_RIGHT ) {
				this.isLayoutRight = true;
			} else {
				this.isLayoutRight = false;
			}
		}
		//System.out.println(" style [" + style.name + "]: right: " + this.isLayoutRight + " center: " + this.isLayoutCenter);
		// vertical styles: vcenter -> bottom -> top
		// expanding layouts:
		if ( ( this.layout & LAYOUT_EXPAND ) == LAYOUT_EXPAND ) {
			this.isLayoutExpand = true;
		} else {
			this.isLayoutExpand = false;
		}
		this.background = style.background;
		this.border = style.border;
		if (this.border != null) {
			this.borderWidth = this.border.borderWidth;
		} else if (this.background != null){
			this.borderWidth = this.background.borderWidth;
		} else {
			this.borderWidth = 0;
		}
		this.paddingLeft = style.paddingLeft;
		this.paddingRight = style.paddingRight;
		this.paddingTop = style.paddingTop;
		this.paddingBottom = style.paddingBottom;
		this.paddingVertical = style.paddingVertical;
		this.paddingHorizontal = style.paddingHorizontal;
		this.marginLeft = style.marginLeft;
		this.marginRight = style.marginRight;
		this.marginTop = style.marginTop;
		this.marginBottom = style.marginBottom;
		//#ifdef polish.css.before
			String beforeUrlStr = style.getProperty("before"); 
			if (beforeUrlStr != null) {
				if ( !beforeUrlStr.equals(this.beforeUrl) ) {
					try {
						this.beforeImage = StyleSheet.getImage(beforeUrlStr, null, true );
						this.beforeWidth = this.beforeImage.getWidth() + this.paddingHorizontal;
						this.beforeHeight = this.beforeImage.getHeight();
					} catch (IOException e) {
						this.beforeUrl = null;
						this.beforeImage = null;
						this.beforeWidth = 0;
						this.beforeHeight = 0;						
					}
				}
			} else {
				this.beforeImage = null;
				this.beforeWidth = 0;
				this.beforeHeight = 0;
			}
			this.beforeUrl = beforeUrlStr;
		//#endif
		//#ifdef polish.css.after
			String afterUrlStr = style.getProperty("after");
			if (afterUrlStr != null) {
				if ( !afterUrlStr.equals(this.afterUrl) ) {
					try {
						this.afterImage = StyleSheet.getImage(afterUrlStr, null, true );
						this.afterWidth = this.afterImage.getWidth() + this.paddingHorizontal;
						this.afterHeight = this.afterImage.getHeight();
					} catch (IOException e) {
						this.afterUrl = null;
						this.afterWidth = 0;
						this.afterHeight = 0;
						this.afterImage = null;
					}
				}
			} else {
				this.afterWidth = 0;
				this.afterHeight = 0;
				this.afterImage = null;
			}
			this.afterUrl = afterUrlStr;
		//#endif
		//#ifdef polish.css.label-style
			Style labStyle = (Style) style.getObjectProperty("label-style");
			if (labStyle != null) {
				this.labelStyle = labStyle;
			} else if (this.labelStyle == null || this.isFocused) {
				this.labelStyle = StyleSheet.labelStyle;
			}
		//#else
			this.labelStyle = StyleSheet.labelStyle;
		//#endif
		if (this.label != null) {
			this.label.setStyle( this.labelStyle );			
		}
		//#ifdef polish.css.min-width
			Integer minWidthInt = style.getIntProperty("min-width");
			if (minWidthInt != null) {
				this.minimumWidth = minWidthInt.intValue();
			}
		//#endif
		//#ifdef polish.css.max-width
			Integer maxWidthInt  = style.getIntProperty("max-width");
			if (maxWidthInt != null) {
				this.maximumWidth = maxWidthInt.intValue();
			}
		//#endif
		//#ifdef polish.css.min-height
			Integer minHeightInt = style.getIntProperty("min-height");
			if (minHeightInt != null) {
				this.minimumHeight = minHeightInt.intValue();
			}
		//#endif
		//#ifdef polish.css.max-height
			Integer maxHeightInt  = style.getIntProperty("max-height");
			if (maxHeightInt != null) {
				this.maximumHeight = maxHeightInt.intValue();
			}
		//#endif
		//#ifdef polish.css.focused-style
			//Object object = style.getObjectProperty("focused-style");
			//if (object != null) {
			//	System.out.println("focused-type: " + object.getClass().getName());
			//}
			Style focused = (Style) style.getObjectProperty("focused-style");
			if (focused != null) {
				this.focusedStyle = focused;
//				if (this instanceof ChoiceGroup) {
//					System.out.println("Setting focused style for choicegroup!");
//				}
			}
		//#endif
		//#if polish.css.colspan
			Integer colSpanInt = style.getIntProperty("colspan");
			if ( colSpanInt != null ) {
				this.colSpan = colSpanInt.intValue();
			}
		//#endif	
		//#if polish.css.include-label
			Boolean includeLabelBool = style.getBooleanProperty("include-label");
			if (includeLabelBool != null) {
				this.includeLabel = includeLabelBool.booleanValue();
			}
		//#endif
		//#ifdef polish.css.view-type
			ItemView viewType = (ItemView) style.getObjectProperty("view-type");
//			if (this instanceof ChoiceGroup) {
//				System.out.println("SET.STYLE / CHOICEGROUP: found view-type (1): " + (viewType != null) + " for " + this);
//			}
			if (viewType != null) {
				if (this.view == null || this.view.getClass() != viewType.getClass()) {
					try {
						if (viewType.parentItem != null) {
							viewType = (ItemView) viewType.getClass().newInstance();
						}
						viewType.parentItem = null;
						this.view = viewType;
					} catch (Exception e) {
						//#debug error
						System.out.println("Container: Unable to init view-type " + e );
						viewType = null;
					}
				}
			}
		//#endif		
	}
	
	/**
	 * Retrieves the complete width of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a StringItem gets a new text.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @return the complete width of this item.
	 */
	public int getItemWidth( int firstLineWidth, int lineWidth ) {
		if (!this.isInitialised || this.itemWidth > lineWidth) {
			init( firstLineWidth, lineWidth );
		}
		return this.itemWidth;
	}

	/**
	 * Retrieves the complete height of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a new style is set.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @return the complete heigth of this item.
	 */
	public int getItemHeight( int firstLineWidth, int lineWidth ) {
		if (!this.isInitialised || this.itemWidth > lineWidth) {
			init( firstLineWidth, lineWidth );
		}
		return this.itemHeight;
	}

	/**
	 * Adds a context sensitive <code>Command</code> to the item.
	 * The semantic type of
	 * <code>Command</code> should be <code>ITEM</code>. The implementation
	 * will present the command
	 * only when the item is active, for example, highlighted.
	 * <p>
	 * If the added command is already in the item (tested by comparing the
	 * object references), the method has no effect. If the item is
	 * actually visible on the display, and this call affects the set of
	 * visible commands, the implementation should update the display as soon
	 * as it is feasible to do so.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be added
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @throws NullPointerException if cmd is null
	 * @since  MIDP 2.0
	 */
	public void addCommand( Command cmd)
	{
		if (this.commands == null) {
			this.commands = new ArrayList();
		}
		if (!this.commands.contains( cmd )) {
			this.commands.add(cmd);
			if (this.appearanceMode == PLAIN) {
				this.appearanceMode = HYPERLINK;
			}
			if (this.isFocused) {
				Screen scr = getScreen();
				if (scr != null) {
					scr.addCommand( cmd );
				}
			}
			if (this.isInitialised) {
				repaint();
			}
		}
	}

	
	
	/**
	 * Requests that this item and all its parents are to be re-initialised at the next repainting.
	 * All parents of this item are notified, too.
	 * This method should be called when an item changes its size more than
	 * usual.
	 * When the item already has been initialised, a repaint() is requested, too.
	 */
	protected void requestInit() {
		//System.out.println("requestInit called by class " + getClass().getName() + " - screen.class=" + getScreen().getClass().getName()  );
		Item p = this.parent;
		while ( p != null) {
			p.isInitialised = false;
			p = p.parent;
		}
		if (this.isInitialised) {
			this.isInitialised = false;
			repaint();
		}
	}
	
	/**
	 * Retrieves the screen to which this item belongs to.
	 * 
	 * @return either the corresponding screen or null when no screen could be found 
	 */
	public Screen getScreen() {
		if (this.screen != null) {
			return this.screen;
		} else if (this.parent != null) {
			Item p = this.parent;
			while (p.parent != null) {
				p = p.parent;
			}
			return p.screen;
		} else {
			return null;
		}
	}

	/**
	 * Removes the context sensitive command from item. If the command is not
	 * in the <code>Item</code> (tested by comparing the object references),
	 * the method has
	 * no effect. If the <code>Item</code> is actually visible on the display,
	 * and this  call
	 * affects the set of visible commands, the implementation should update
	 * the display as soon as it is feasible to do so.
	 * 
	 * 
	 * If the command to be removed happens to be the default command,
	 * the command is removed and the default command on this Item is
	 * set to <code>null</code>.
	 * 
	 * The following code:
	 * <CODE> <pre>
	 * // Command c is the default command on Item item
	 * item.removeCommand(c);
	 * </pre> </CODE>
	 * is equivalent to the following code:
	 * <CODE> <pre>
	 * // Command c is the default command on Item item
	 * item.setDefaultCommand(null);
	 * item.removeCommand(c);
	 * </pre> </CODE>
	 * 
	 * @param cmd - the command to be removed
	 * @since  MIDP 2.0
	 */
	public void removeCommand( Command cmd ) {
		if (this.commands != null) {
			if (cmd == this.defaultCommand) {
				this.defaultCommand = null;
			}
			if (this.commands.remove(cmd)) {
				if (this.isFocused) {
					Screen scr = getScreen();
					if (scr != null) {
						scr.removeCommand( cmd );
					}
				}
				if (this.isInitialised) {
					repaint();
				}
			}
		}
	}

	/**
	 * Sets a listener for <code>Commands</code> to this <code>Item</code>,
	 * replacing any previous
	 * <code>ItemCommandListener</code>. A <code>null</code> reference
	 * is allowed and has the effect of removing any existing listener.
	 * 
	 * When no listener is registered, J2ME Polish notifies the 
	 * command-listener of the current screen, when an item command 
	 * has been selected.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param l the new listener, or null.
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setItemCommandListener( ItemCommandListener l)
	{
		this.itemCommandListener = l;
	}

	/**
	 * Gets the preferred width of this <code>Item</code>.
	 * If the application has locked
	 * the width to a specific value, this method returns that value.
	 * Otherwise, the return value is computed based on the
	 * <code>Item's</code> contents,
	 * possibly with respect to the <code>Item's</code> preferred height
	 * if it is locked.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the preferred width of the Item
	 * @see #getPreferredHeight()
	 * @see #setPreferredSize(int, int)
	 * @since  MIDP 2.0
	 */
	public int getPreferredWidth()
	{
		return this.preferredWidth;
	}

	/**
	 * Gets the preferred height of this <code>Item</code>.
	 * If the application has locked
	 * the height to a specific value, this method returns that value.
	 * Otherwise, the return value is computed based on the
	 * <code>Item's</code> contents,
	 * possibly with respect to the <code>Item's</code> preferred
	 * width if it is locked.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the preferred height of the Item
	 * @see #getPreferredWidth()
	 * @see #setPreferredSize(int, int)
	 * @since  MIDP 2.0
	 */
	public int getPreferredHeight()
	{
		return this.preferredHeight;
	}

	/**
	 * Sets the preferred width and height for this <code>Item</code>.
	 * Values for width and height less than <code>-1</code> are illegal.
	 * If the width is between zero and the minimum width, inclusive,
	 * the minimum width is used instead.
	 * If the height is between zero and the minimum height, inclusive,
	 * the minimum height is used instead.
	 * 
	 * <p>Supplying a width or height value greater than the minimum width or
	 * height <em>locks</em> that dimension to the supplied
	 * value.  The implementation may silently enforce a maximum dimension for
	 * an <code>Item</code> based on factors such as the screen size.
	 * Supplying a value of
	 * <code>-1</code> for the width or height unlocks that dimension.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.</p>
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param width - the value to which the width should be locked, or -1 to unlock
	 * @param height - the value to which the height should be locked, or -1 to unlock
	 * @throws IllegalArgumentException - if width or height is less than -1
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @see #getPreferredHeight()
	 * @see #getPreferredWidth()
	 * @since  MIDP 2.0
	 */
	public void setPreferredSize(int width, int height)
	{
		this.preferredHeight = height;
		this.preferredWidth = width;
	}

	/**
	 * Gets the minimum width for this <code>Item</code>.  This is a width
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum width of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumWidth()
	{
		return this.minimumWidth;
	}

	/**
	 * Gets the minimum height for this <code>Item</code>.  This is a height
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumHeight()
	{
		return this.minimumHeight;
	}

	/**
	 * Sets default <code>Command</code> for this <code>Item</code>.
	 * If the <code>Item</code> previously had a
	 * default <code>Command</code>, that <code>Command</code>
	 * is no longer the default, but it
	 * remains present on the <code>Item</code>.
	 * 
	 * <p>If not <code>null</code>, the <code>Command</code> object
	 * passed becomes the default <code>Command</code>
	 * for this <code>Item</code>.  If the <code>Command</code> object
	 * passed is not currently present
	 * on this <code>Item</code>, it is added as if <A HREF="../../../javax/microedition/lcdui/Item.html#addCommand(javax.microedition.lcdui.Command)"><CODE>addCommand(javax.microedition.lcdui.Command)</CODE></A>
	 * had been called
	 * before it is made the default <code>Command</code>, unless the &quot;polish.Item.suppressDefaultCommand&quot; preprocessing variable is set to &quot;true&quot;.</p>
	 * 
	 * <p>If <code>null</code> is passed, the <code>Item</code> is set to
	 * have no default <code>Command</code>.
	 * The previous default <code>Command</code>, if any, remains present
	 * on the <code>Item</code>.
	 * </p>
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be used as this Item's default Command, or null if there is to be no default command
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setDefaultCommand( Command cmd)
	{
		//#if !polish.Item.suppressDefaultCommand
		if (this.defaultCommand != null && cmd != this.defaultCommand) {
			addCommand(this.defaultCommand);
		}
		//#endif		
		this.defaultCommand = cmd;
		//#if !polish.Item.suppressDefaultCommand
		if (cmd != null) {
			addCommand(cmd);
		}
		//#endif
	}

	/**
	 * Causes this <code>Item's</code> containing <code>Form</code> to notify
	 * the <code>Item's</code> <CODE>ItemStateListener</CODE>.
	 * The application calls this method to inform the
	 * listener on the <code>Item</code> that the <code>Item's</code>
	 * state has been changed in
	 * response to an action.  Even though this method simply causes a call
	 * to another part of the application, this mechanism is useful for
	 * decoupling the implementation of an <code>Item</code> (in particular, the
	 * implementation of a <code>CustomItem</code>, though this also applies to
	 * subclasses of other items) from the consumer of the item.
	 * 
	 * <p>If an edit was performed by invoking a separate screen, and the
	 * editor now wishes to &quot;return&quot; to the form which contained the
	 * selected <code>Item</code>, the preferred method is
	 * <code>Display.setCurrent(Item)</code>
	 * instead of <code>Display.setCurrent(Displayable)</code>,
	 * because it allows the
	 * <code>Form</code> to restore focus to the <code>Item</code>
	 * that initially invoked the editor.</p>
	 * 
	 * <p>In order to make sure that the documented behavior of
	 * <code>ItemStateListener</code> is maintained, it is up to the caller
	 * (application) to guarantee that this function is
	 * not called unless:</p>
	 * 
	 * <ul>
	 * <li>the <code>Item's</code> value has actually been changed, and</li>
	 * <li>the change was the result of a user action (an &quot;edit&quot;)
	 * and NOT as a result of state change via calls to
	 * <code>Item's</code> APIs </li>
	 * </ul>
	 * 
	 * <p>The call to <code>ItemStateListener.itemStateChanged</code>
	 * may be delayed in order to be serialized with the event stream.
	 * The <code>notifyStateChanged</code> method does not block awaiting
	 * the completion of the <code>itemStateChanged</code> method.</p>
	 * 
	 * @throws IllegalStateException if the Item is not owned by a Form
	 * @since  MIDP 2.0
	 */
	public void notifyStateChanged()
	{
		
		Screen scr = StyleSheet.currentScreen;
		if (scr == null) {
			scr = getScreen();
		}
		//#ifndef polish.skipArgumentCheck
			if ( (!(scr instanceof Form)) || (scr == null)) {
				//#ifdef polish.verboseDebug
					throw new IllegalStateException("notifyStateChanged() is valid only for items in Forms.");
				//#else
					//# throw new IllegalStateException();
				//#endif
			}
		//#endif
//		((Form) scr).addToStateNotifyQueue(this);
	}
	
	/**
	 * Paints this item on the screen.
	 * This method should normally not be overriden. Override it
	 * only when you know what you are doing!
	 * 
	 * @param x the left start position of this item.
	 * @param y the top start position of this item.
	 * @param leftBorder the left border, nothing must be painted left of this position
	 * @param rightBorder the right border, nothing must be painted right of this position,
	 * 		  rightBorder > x >= leftBorder
	 * @param g the Graphics on which this item should be painted.
	 */
	public void paint( int x, int y, int leftBorder, int rightBorder, Graphics g ) {
		// initialise this item if necessary:
		int availableWidth = rightBorder - leftBorder;
		int originalX = x;
		int originalY = y;
		if (!this.isInitialised || (availableWidth < this.itemWidth )) {
			//#if polish.debug.info
			if (availableWidth < this.itemWidth ) {
				//#debug info
				System.out.println("re-initializing item " + this + " for availableWidth=" + availableWidth + ", itemWidth=" + this.itemWidth);
			}
			//#endif
			init( rightBorder - x, availableWidth );
		}
		boolean isLayoutShrink = (this.layout & LAYOUT_SHRINK) == LAYOUT_SHRINK;
		
		// paint background and border when the label should be included in this:
		//#if polish.css.include-label
			if (this.includeLabel) {
				int width = this.itemWidth - this.marginLeft - this.marginRight;
				int height = this.itemHeight - this.marginTop - this.marginBottom;
				int bX = x + this.marginLeft;
				int bY = y + this.marginTop + this.backgroundYOffset;
				if ( this.background != null ) {
					this.background.paint(bX, bY, width, height, g);
				}
				if ( this.border != null ) {
					this.border.paint(bX, bY, width, height, g);
				}
			}
		//#endif
		
		// paint label:
		if (this.label != null) {
			if (this.useSingleRow) {
				this.label.paint( x, y, leftBorder, rightBorder - (this.contentWidth + this.paddingHorizontal), g );
				x += this.label.itemWidth;
				leftBorder += this.label.itemWidth;
			} else {
				this.label.paint( x, y, leftBorder, rightBorder, g );
				y += this.label.itemHeight;
			}
		}
		
		leftBorder += (this.marginLeft + this.borderWidth + this.paddingLeft);
		//#ifdef polish.css.before
			leftBorder += this.beforeWidth;
		//#endif
		//System.out.println( this.style.name + ":  increasing leftBorder by " + (this.marginLeft + this.borderWidth + this.paddingLeft));
		rightBorder -= (this.marginRight + this.borderWidth + this.paddingRight);
		//#ifdef polish.css.after
			rightBorder -= this.afterWidth;
		//#endif

		//System.out.println( this.style.name + ":  decreasing rightBorder by " + (this.marginRight + this.borderWidth + this.paddingRight));
		if ( this.isLayoutCenter  && availableWidth > this.itemWidth) {
			int difference = (availableWidth - this.itemWidth) / 2; 
			x += difference;
			if (isLayoutShrink) {
				leftBorder += difference;
				rightBorder -= difference;
				//System.out.println("item " + this + ": (center) shrinking left border to " + leftBorder + ", right border to " + rightBorder);
			}
		} else if ( this.isLayoutRight && availableWidth > this.itemWidth) {
			// adjust the x-position so that the item is painted up to
			// the right border (when it starts at x):
			x += availableWidth - this.itemWidth;
			if (isLayoutShrink) {
				leftBorder += availableWidth - this.itemWidth;
				//System.out.println("item " + this + ": (right) shrinking left border to " + leftBorder);
			}
		} else if (isLayoutShrink && availableWidth > this.itemWidth) {
			rightBorder -= availableWidth - this.itemWidth;
			//System.out.println("item " + this + ": (left) shrinking right border to " + rightBorder);
		}
		
		// paint background:
		x += this.marginLeft;
		y += this.marginTop;
		//#if polish.css.include-label
			if (!this.includeLabel) {
		//#endif
				if (this.background != null) {
					this.background.paint(x, y + this.backgroundYOffset, this.backgroundWidth, this.backgroundHeight, g);
				}
				// paint border:
				if (this.border != null) {
					this.border.paint(x, y + this.backgroundYOffset, this.backgroundWidth, this.backgroundHeight, g);
				}
		//#if polish.css.include-label
			}
		//#endif
		
		x += this.borderWidth + this.paddingLeft;
		y += this.borderWidth + this.paddingTop;
		int originalContentY = y;
		
		// paint before element:
		//#if polish.css.before || polish.css.after || polish.css.min-height  || polish.css.max-height
			boolean isVerticalCenter = (this.layout & LAYOUT_VCENTER) == LAYOUT_VCENTER; 
			boolean isTop = !isVerticalCenter && (this.layout & LAYOUT_TOP) == LAYOUT_TOP; 
			boolean isBottom = !isVerticalCenter && (this.layout & LAYOUT_BOTTOM) == LAYOUT_BOTTOM; 
		//#endif
		//#if polish.css.min-height
			if (this.minimumHeight != 0) {
				int minHeight = this.minimumHeight - ( 2 * this.borderWidth + this.marginTop + this.marginBottom + this.paddingTop + this.paddingBottom);
				if ( isVerticalCenter ) {
//					System.out.println("vertical: adjusting contY by " + ((this.minimumHeight - this.contentHeight) / 2)
//							+ ", contentHeight=" + this.contentHeight + ", minHeight=" + this.minimumHeight );
					y += (minHeight - this.contentHeight) / 2; 
				} else if ( isBottom ) {
					//System.out.println("bottom: adjusting contY by " + (this.minimumHeight - this.contentHeight) );
					y += (minHeight - this.contentHeight);
				}
			}
		//#endif
		//#ifdef polish.css.before
			if (this.beforeImage != null) {
				int beforeY = y;
				int yAdjustment = this.beforeHeight - this.contentHeight;
				if ( this.beforeHeight < this.contentHeight) {
					if (isTop) {
						beforeY -= yAdjustment;
					} else if (isBottom) {
						beforeY += yAdjustment;
					} else {
						beforeY -= yAdjustment / 2;
					}
				} else {
					if (isTop) {
						// keep contY
					} else if (isBottom) {
						y += yAdjustment;
					} else {
						y += yAdjustment / 2;
					}
					//contY += (this.beforeHeight - this.contentHeight) / 2;
				}
				g.drawImage(this.beforeImage, x, beforeY, Graphics.TOP | Graphics.LEFT );
				x += this.beforeWidth;
			}
		//#endif
		
		// paint after element:
		//#ifdef polish.css.after
			if (this.afterImage != null) {
				int afterY = originalContentY;
				int yAdjustment = this.afterHeight - this.contentHeight;
				if ( this.afterHeight < this.contentHeight) {
					if (isTop) {
						afterY -= yAdjustment;
					} else if (isBottom) {
						afterY += yAdjustment;
					} else {
						afterY -= yAdjustment / 2;
					}
					//afterY += (this.contentHeight - this.afterHeight) / 2;
				} else {
					//#ifdef polish.css.before
					if (this.afterHeight > this.beforeHeight) {
					//#endif
						if (isTop) {
							// keep contY
						} else if (isBottom) {
							y = originalContentY + yAdjustment;
						} else {
							y = originalContentY + yAdjustment / 2;
						}
						//contY = originalContentY + (this.afterHeight - this.contentHeight) / 2;
					//#ifdef polish.css.before
					}
					//#endif
				}
				g.drawImage(this.afterImage, rightBorder, afterY, Graphics.TOP | Graphics.LEFT );
			}
		//#endif
		

		// paint content:
		this.contentX = x - originalX;
		this.contentY = y - originalY;
		//#ifdef polish.css.view-type
			if (this.view != null) {
//				this.view.paintContent( this, x, y, leftBorder, rightBorder, g);
			} else {
		//#endif
				paintContent( x, y, leftBorder, rightBorder, g );				
		//#ifdef polish.css.view-type
			}
		//#endif
	}
	
	/**
	 * Initialises this item.
	 * You should always call super.init( firstLineWidth, lineWidth) when overriding this method.
	 * This method call either ItemView.initContent() or Item.initContent() to initialize the actual content.
	 * A valid case for overriding would be if additional initialization needs to be done even when an
	 * ItemView is associated with this Item. Usually implementing initContent() should suffice.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @see #initContent(int, int)
	 * @see ItemView#initContent(Item, int, int)
	 */
	protected void init( int firstLineWidth, int lineWidth ) {
		//#debug
		System.out.println("intialising item " + this.getClass().getName() + " (" + this + ")");
		if (this.style != null && !this.isStyleInitialised) {
			setStyle( this.style );
		}
		//#ifdef polish.useDynamicStyles
			else if (this.style == null) {
				initStyle();
			}
		//#else
			else if (this.style == null && !this.isStyleInitialised) {
				//#debug
				System.out.println("Setting default style for item " + getClass().getName() );
				setStyle( StyleSheet.defaultStyle );
			}
		//#endif
		int labelWidth = 0;
		int labelHeight = 0;
		if (this.label != null) {
			if (!this.label.isInitialised) {
				this.label.init( firstLineWidth, lineWidth );
			}
			labelWidth = this.label.itemWidth;
			labelHeight = this.label.itemHeight;
		}
		// calculate content width and content height:
		int noneContentWidth =  
			 	this.marginLeft + this.borderWidth + this.paddingLeft 
				+ this.paddingRight + this.borderWidth + this.marginRight;
		//#ifdef polish.css.before
			noneContentWidth += this.beforeWidth;
		//#endif
		//#ifdef polish.css.after
			noneContentWidth += this.afterWidth;
		//#endif
		/*
		if (noneContentWidth >= firstLineWidth) {
			System.out.println("INVALID NONE CONTENT WIDTH=" + noneContentWidth);
		}
		*/
		//#ifdef polish.css.max-width
			int firstLineAdjustedWidth = firstLineWidth;
			int lineAdjustedWidth = lineWidth;
			if (this.maximumWidth != 0 ) {
				if (firstLineAdjustedWidth > this.maximumWidth ) {
					firstLineAdjustedWidth = this.maximumWidth;
				} 
				if (lineAdjustedWidth > this.maximumWidth ) {
					lineAdjustedWidth = this.maximumWidth;
				}
			}
			int firstLineContentWidth = firstLineAdjustedWidth - noneContentWidth;
			int availableContentWidth = lineAdjustedWidth - noneContentWidth;
		//#else
			//# int firstLineContentWidth = firstLineWidth - noneContentWidth;
			//# int availableContentWidth = lineWidth - noneContentWidth;
		//#endif
		
		// initialise content by subclass:
		//#ifdef polish.css.view-type
			if (this.view != null) {
//				this.view.initContent(this, firstLineContentWidth, availableContentWidth);
				this.contentWidth = this.view.contentWidth;
				this.contentHeight = this.view.contentHeight;
			} else {
		//#endif
				initContent( firstLineContentWidth, availableContentWidth );
		//#ifdef polish.css.view-type
			}
		//#endif
		
		if (this.contentWidth == 0 && this.contentHeight == 0) {
			this.itemWidth = labelWidth;
			this.itemHeight = labelHeight;
			this.backgroundHeight = 0;
			this.backgroundWidth = 0;
			this.isInitialised = true;
			return;
		}
		this.itemWidth = noneContentWidth + this.contentWidth;
		//#ifdef polish.css.min-width
		if (this.itemWidth < this.minimumWidth ) {
			this.itemWidth = this.minimumWidth;
		}
		//#endif
		int cHeight = this.contentHeight;
		//#ifdef polish.css.before
			if (this.contentHeight < this.beforeHeight) {
				cHeight = this.beforeHeight;
			}
		//#endif
		//#ifdef polish.css.after
			if (this.contentHeight < this.afterHeight) {
				cHeight = this.afterHeight;
			}
		//#endif
		int noneContentHeight = this.marginTop + this.borderWidth + this.paddingTop 
			  + this.paddingBottom + this.borderWidth + this.marginBottom;
		if (this.itemWidth + labelWidth <= lineWidth) {
			// label and content fit on one row:
			this.itemWidth += labelWidth;
			this.useSingleRow = true;
			if (this.label != null) {
				if ( (this.label.layout & LAYOUT_NEWLINE_AFTER) != 0 || ((this.layout & LAYOUT_NEWLINE_BEFORE) == LAYOUT_NEWLINE_BEFORE )) {
					this.useSingleRow = false;
					cHeight += labelHeight;
				}
			}
			if ( cHeight + noneContentHeight < labelHeight ) {
				cHeight = labelHeight - noneContentHeight;
			}
		} else {
			this.useSingleRow = false;
			cHeight += labelHeight;
		}
		if ( this.isLayoutExpand ) {
			this.itemWidth = lineWidth;
			//#ifdef polish.css.max-width
				if (this.maximumWidth != 0 && lineWidth > this.maximumWidth ) {
					this.itemWidth = this.maximumWidth;
				}
			//#endif
		} else if (this.itemWidth > lineWidth) {
			this.itemWidth = lineWidth;
		}
		if (cHeight + noneContentHeight < this.minimumHeight) {
			cHeight = this.minimumHeight - noneContentHeight;
		}
		//#if polish.css.max-height
			if (this.maximumHeight != 0 && cHeight + noneContentHeight > this.maximumHeight) {
				cHeight = this.maximumHeight - noneContentHeight;
			}
		//#endif
		this.itemHeight = cHeight + noneContentHeight;
		if (this.useSingleRow) {
			this.backgroundWidth = this.itemWidth - this.marginLeft - this.marginRight - labelWidth;
			this.backgroundHeight = cHeight
							  + noneContentHeight
							  - this.marginTop
							  - this.marginBottom;
		} else {
			this.backgroundWidth = this.itemWidth - this.marginLeft - this.marginRight;
			this.backgroundHeight = cHeight
							  + noneContentHeight
							  - this.marginTop
							  - this.marginBottom
							  - labelHeight;
		}
		this.isInitialised = true;
		//#debug
		System.out.println("Item.init(): contentWidth=" + this.contentWidth + ", itemWidth=" + this.itemWidth + ", backgroundWidth=" + this.backgroundWidth);
	}
	
	//#ifdef polish.useDynamicStyles
	/**
	 * Initialises the appropriate style for this item.
	 */
	protected void initStyle() {
		//System.out.println("item [" + this.getClass().getName() + "/" + this.cssSelector + "/" + this.hashCode() + "] has been initalised: " + this.isStyleInitialised );
		if (this.screen == null) {
			if (this.parent != null) {
				this.screen = getScreen();
			} else {
				this.screen = StyleSheet.currentScreen;
			}
		}
		if (this.style == null) {
			this.cssSelector = createCssSelector();
			//#debug
			System.out.println("getting style for item [" + this.cssSelector + "].");
//			setStyle( StyleSheet.getStyle( this ) );
		} else {
			//System.out.println("item has already style [" + this.style.name + "].");
			this.cssSelector = this.style.name;
		}
		this.isStyleInitialised = true;
	}
	//#endif
	

	/**
	 * Initialises this item. 
	 * The implementation needs to calculate and set the contentWidth and 
	 * contentHeight fields. 
	 * The implementation should take the fields preferredWidth and preferredHeight
	 * into account.
	 * 
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @see #contentWidth
	 * @see #contentHeight
	 * @see #preferredWidth
	 * @see #preferredHeight
	 */
	protected abstract void initContent(int firstLineWidth, int lineWidth);
	
	
	/**
	 * Paints the content of this item.
	 * The background has already been painted and the border will be added after
	 * this method returns.
	 * 
	 * @param x the left start position
	 * @param y the upper start position
	 * @param leftBorder the left border, nothing must be painted left of this position
	 * @param rightBorder the right border, nothing must be painted right of this position
	 * @param g the Graphics on which this item should be painted.
	 */
	protected abstract void paintContent( int x, int y, int leftBorder, int rightBorder, Graphics g );
	
	//#ifdef polish.useDynamicStyles	
	/**
	 * Retrieves the CSS selector for this item.
	 * The CSS selector is used for the dynamic assignment of styles -
	 * that is the styles are assigned by the usage of the item and
	 * not by a predefined style-name.
	 * With the #style preprocessing command styles are set fix, this method
	 * yields in a faster GUI and is recommended. When in a style-sheet
	 * dynamic styles are used, e.g. "Form>p", than the selector of the
	 * item is needed.
	 * <br/>
	 * This abstract method needs only be implemented, when dynamic styles
	 * are used: #ifdef polish.useDynamicStyles
	 * <br/>
	 * The returned selector needs to be in lower case. 
	 * 
	 * @return the appropriate CSS selector for this item.
	 * 			The selector needs to be in lower case.
	 */
	protected abstract String createCssSelector();	
	//#endif

	/**
	 * Handles the key-pressed event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default implementation just handles the FIRE game-action
	 * when a default-command and an item-command-listener have been
	 * registered.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 */
	protected boolean handleKeyPressed( int keyCode, int gameAction ) {
		//#debug
		System.out.println("item " + this + ": handling keyPressed for keyCode=" + keyCode + ", gameAction=" + gameAction);
		if ((gameAction == Canvas.FIRE) 
				&& (this.defaultCommand != null)
				&& (this.itemCommandListener != null)) {
//			this.itemCommandListener.commandAction(this.defaultCommand, this);
			return true;
		}
		return false;
	}
	
	/**
	 * Handles the key-repeated event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default implementation forwards the event to the handleKeyPressed method.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 * @see #handleKeyPressed(int, int)
	 */
	protected boolean handleKeyRepeated( int keyCode, int gameAction ) {
		return handleKeyPressed(keyCode, gameAction);
	}
	
	/**
	 * Handles the key-released event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * The default does nothing.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return true when the key has been handled / recognized
	 * @see #handleKeyPressed(int, int)
	 */
	protected boolean handleKeyReleased( int keyCode, int gameAction ) {
		return false;
	}

	
	/**
	 * Determines whether the given relative x/y position is inside of this item's content area.
	 * Subclasses which extend their area over the declared/official content area, which is determined
	 * in the initContent() method (like popup items), might want to override this method or possibly the getContentX(), getContentY() methods.
	 * It is assumed that the item has been initialized before.
	 * 
	 * @param relX the x position relative to this item's left position
	 * @param relY the y position relative to this item's top position
	 * @return true when the relX/relY coordinate is within this item's content area.
	 * @see #initContent(int, int)
	 */
	public boolean isInContentArea( int relX, int relY ) {
		int contTop = this.contentY;
		if ( relY < contTop || relY > contTop + this.contentHeight ) {
			return false;
		}
		int contLeft = this.contentX;
		if (relX < contLeft || relX > contLeft + this.contentWidth) {
			return false;
		}
		return true;
	}

	/**
	 * Determines whether the given relative x/y position is inside of this item's area including paddings, margins and label.
	 * Subclasses which extend their area over the declared/official content area, which is determined
	 * in the initContent() method (like popup items), might want to override this method.
	 * It is assumed that the item has been initialized before.
	 * 
	 * @param relX the x position relative to this item's left position
	 * @param relY the y position relative to this item's top position
	 * @return true when the relX/relY coordinate is within this item's area.
	 * @see #initContent(int, int)
	 */
	public boolean isInItemArea( int relX, int relY ) {
		// problem:
		// itemWidth can be smaller than the available width - when then a center or right layout is used, then this fucks up...
		if (relY < 0 || relY > this.itemHeight || relX < 0 || relX > this.itemWidth) {
			System.out.println("isInItemArea(" + relX + "," + relY + ") = false: itemWidth=" + this.itemWidth + ", itemHeight=" + this.itemHeight + " (" + this + ")");
			return false;
		}
		System.out.println("isInItemArea(" + relX + "," + relY + ") = true: itemWidth=" + this.itemWidth + ", itemHeight=" + this.itemHeight + " (" + this + ")");
		return true;
	}
	
	//#ifdef polish.hasPointerEvents
	/**
	 * Handles the event when a pointer has been pressed at the specified position.
	 * The default method discards this event when relX/relY is outside of the item's area.
	 * When the event took place inside of the content area, the pointer-event is translated into an artificial
	 * FIRE game-action keyPressed event, which is subsequently handled
	 * bu the handleKeyPressed(-1, Canvas.FIRE) method.
	 * This method needs should be overwritten only when the "polish.hasPointerEvents"
	 * preprocessing symbol is defined: "//#ifdef polish.hasPointerEvents".
	 *    
	 * @param relX the x position of the pointer pressing relative to this item's left position
	 * @param relY the y position of the pointer pressing relative to this item's top position
	 * @return true when the pressing of the pointer was actually handled by this item.
	 * @see #isInItemArea(int, int) this method is used for determining whether the event belongs to this item
	 * @see #isInContentArea(int, int) for a helper method for determining whether the event took place into the actual content area
	 * @see #handleKeyPressed(int, int) 
	 */
	protected boolean handlePointerPressed( int relX, int relY ) {
		if ( isInItemArea(relX, relY)) {
			return handleKeyPressed( -1, Canvas.FIRE );
		}
		return false;
	}
	//#endif
	
	/**
	 * Animates this item.
	 * Subclasses can override this method to create animations.
	 * The default implementation just animates the background if present.
	 * 
	 * @return true when this item has been animated.
	 */
	public boolean animate() {
		if (this.background != null) {
			return this.background.animate();
		}
		return false;
	}

	/**
	 * Focuses this item.
	 * 
	 * @param newStyle the style which is used to indicate the focused state
	 * @param direction the direction from which this item is focused,
	 *        either Canvas.UP, Canvas.DOWN, Canvas.LEFT, Canvas.RIGHT or 0.
	 *        When 0 is given, the direction is unknown.
	 * @return the current style of this item
	 */
	protected Style focus( Style newStyle, int direction ) {
		Style oldStyle = this.style;
		if (this.focusedStyle != null) {
			newStyle = this.focusedStyle;
		} 
		setStyle( newStyle );
		this.isFocused = true;
		// now set any commands of this item:
		if (this.commands != null) {
			Screen scr = getScreen();
			if (scr != null) {
//				scr.setItemCommands(this);
			}
		}
		// when an item is focused, it usually grows bigger, so
		// increase the bottom position a bit:
		this.itemHeight += 5;
		if (oldStyle == null) {
			oldStyle = StyleSheet.defaultStyle;
		}
		return oldStyle;
	}
	
	/**
	 * Removes the focus from this item.
	 * 
	 * @param originalStyle the original style which will be restored.
	 */
	protected void defocus( Style originalStyle ) {
		this.backgroundYOffset = 0;
		if (originalStyle != null) {
			setStyle( originalStyle );
		} else {
			this.background = null;
			this.border = null;
			this.style = null;
		}
		this.isFocused = false;
		// now remove any commands which are associated with this item:
		if (this.commands != null) {
			Screen scr = getScreen();
			if (scr != null) {
//				scr.removeItemCommands(this);
			}
		}
	}

	/**
	 * Called by the system to notify the item that it is now at least
	 * partially visible, when it previously had been completely invisible.
	 * The item may receive <code>paint()</code> calls after
	 * <code>showNotify()</code> has been called.
	 * 
	 * <p>The default implementation of this method does nothing.</p>
	 */
	protected void showNotify()
	{
		//default implementation does nothing
	}

	/**
	 * Called by the system to notify the item that it is now completely
	 * invisible, when it previously had been at least partially visible.  No
	 * further <code>paint()</code> calls will be made on this item
	 * until after a <code>showNotify()</code> has been called again.
	 * 
	 * <p>The default implementation of this method does nothing.</p>
	 */
	protected void hideNotify()
	{
		//default implementation does nothing
	}
	
	/**
	 * Shows the screen to which item belongs to and focusses this item.
	 * This method is the equivalent to display.setCurrentItem( item ).
	 * 
	 * @param display the display of the MIDlet.
	 */
	public void show( Display display ) {
		Screen myScreen = getScreen();
		if ( myScreen == null ) {
			//#debug warn
			System.out.println("Unable to show this item, since the screen is not known.");
			return;
		}
		
//		myScreen.focus( this );
		display.setCurrent( myScreen );
	}
	
	/**
	 * Releases all (memory intensive) resources such as images or RGB arrays of this item.
	 * The default implementation releases any background resources.
	 */
	public void releaseResources() {
		if (this.background != null) {
			this.background.releaseResources();
		}
	}

	/**
	 * Sets an arbitrary attribute for this item.
	 * 
	 * @param key the key for the attribute
	 * @param value the attribute value
	 */
	public void setAttribute( Object key, Object value ) {
		if (this.attributes == null) {
			this.attributes = new HashMap();
		}
		this.attributes.put( key, value );
	}
	
	/**
	 * Gets an previously added attribute of this item.
	 * 
	 * @param key the key of the attribute
	 * @return the attribute value, null if none has been registered under the given key before
	 */
	public Object getAttribute( Object key ) {
		if (this.attributes == null) {
			return null;
		}
		return this.attributes.get( key );
	}
  
  /**
   * Returns a HashMap object with all registered attributes.
   * 
   * @return a HashMap object with all attribute key/value pairs, null if no attribute was stored before.
   */
  public HashMap getAttributes() {
    return this.attributes;
  }

}
