NEXT:
- Den j2me polish Ant task aus dem Plugin heraus laden und so an die konfigurierten Geräte und
requirements zu kommen.
- Jede capability wird zu einem symbol polish.javaplatform:defined und die Werte zu
polish.javaplatform.mmapi, ...
- Für die capabilites gibts zusatzinfos in capabilites.xml, die ebenfalls angezeit werden sollten.
- es kann sein, dass die capabilites.xml und co. woanders liegen. Deren Position steht im build.xml
  und sollte daher durch ant eingeparst werden.

- when a variable is marked in the code it should be marked in //#= directives, too.

- within //#= directive the 'this' is not colored.

ANT

- The goal is to utilize ant to execute parts of a task.

- To do that construct a Project as an environment for the task.

- Entry point is Lauchner.run(...).

- Interessting part starts in Main.runBuild(...).
  . project.init().
  . some project.setUserPreference("ant.file",""); and project.setUserPreference("ant.version","");
  . possible commandline properties
  . set system property HELPER_PROPERTY to 'ProjectHelper2'
  . ProjectHelper.getProjectHelper() returns helper set in property.
  . ProjectHelper.configureProject(project,this.buildfile);
  . look at maybeconfigured() in Task. Do we need that?




NAMING

All Plugins
de.enough.mepose.cssEditor
de.enough.mepose.paEditor (preprocessing aware editor)
de.enough.mepose.MessagesEditor
de.enough.mepose.core (what to put in it? Maybe the current device? 'core' may be a feature name)
de.enough.mepose.project (together with builders)
de.enough.mepose.projectWizard (configuring project with nature and setting up build.xml)
de.enough.mepose.deviceManager (select device from requirements originating from build.xml or from interactive input)

AllFeatures
org.j2mepolish.mepose.mainFeature

Usage of the term 'mepose'
http://groups.msn.com/IMAGEHOSTING/evilkandykane.msnw
http://groups.msn.com/IMAGEHOSTING/evilkandykane.msnw?action=ShowPhoto&PhotoID=918
Some french sites from google.



IRC (in this channels eclipse developers from redhat were seen recently.)
irc.oftc.net #gcj
irc.freenode.net #classpath. wenden an: overholt, pmuldoon, scsibear, Michael ist man-di



TODO:

- Change BlockMarker to new schema.
- implement extractSymbolAtOffset and SymbolCompletionProcessor
- replace all system.out.println with plugin.log messages.
- Make all error messages aswer the following:
    Where did the error occurred (class,method,position)? What happend (technically with exception/condition,semanticly if no obvious)? Why did it happen? (technically with numbers,semanticly if no obvious)
- Terminology: offset and position: a position is mutable and may have different roles like startPosition, currentPosition. An offset is one special position in a series of possible positions.
- move updateSite stuff to seperate build project to have a clear cut. DONE
- ant file cleanup and enhancement.
- change names arcording to naming schema.
- Code cleanup: plugin structure, package structure, javadoc.
- optimize mark occurrences. refactor marker.
- migrate all org.eclipse.ui.actionSetPartAssociations with id of CompilationUnitEditor to PolishEditor.
- recognize symbol and variable names.
- Solve problem with instant property change. DONE
- Create a nature and register polish editor as default editor for .java. DONE
- Make the nature chooseable. DONE
- Make all colors work. DONE
- Get mark occurrences working. DONE
- Create updatesite with webbrowser access. DONE
- Bug: at org.eclipse.core.internal.resources.Project.setDescription(Project.java:905). DONE
- try to get indention working. DONE
- defensive programming EVERYWHERE.
- use resourcebundles everywhere.
- register polish editor as default in mepose projects.



PROBLEMS:

- registering polish editor as default causes problems. Sometimes an editor is null somewhere.
- problematic interaction if using negative lookahead and lookinAt(): The negative lookahead must
  be specified in reverse order (!). The lookinAt() method will not match the pattern, the find() will.
  "(?!ba)cd" matches "abcd" but "(?!ab)cd" will not.


DESIGN DECITIONS:

syntax highlighting: overload the getSingleLineCommentScanner from JavaSourceViewerConfiguration.
Having a own partition is difficult because it would overlap with content type SINGLE_LINE_COMMENT.
Alternative: overload FastJavaPartitionScanner and return new content type for //#. Problems: Use of partitions is
hardwired everywhere in the jdt


THINGS TO COKE ON

JavaEditor.removeOccurrenceAnnotations(...)

This method is package private which it should not be.

---

org.eclipse.swt.widgets.EventTable

public void sendEvent (Event event) {
	if (types == null) return;
	level++;
	try {
		for (int i=0; i<types.length; i++) {
			if (event.type == SWT.None) return;
			if (types [i] == event.type) {
				Listener listener = listeners [i];
				if (listener != null) listener.handleEvent (event);
			}
		}
	} finally {
		--level;
	}
}

Doesnt indicate the first neasted if clause a confused programmer? The check if the parameter has a specific type
does not belong in a loop! Like the first if clause which examines the parameter, the second if clause
should be located at the top, too.

---

org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(...)

Uses ArrayIndexOutBoundsException to test on end of array as part of the alogrithm !
How many books and opinions has someone to avoid to not read that exceptions are reserved
for, well, exceptional situations. The end of an array traversal is not exceptional in a
algorithmical sense (unless you are used to operate on a real turing machine of curse)


---

org.eclipse.compare.internal.BaseCompareAction implements IActionDelegate

changing the fundametal contract of OO programming between super- and subclass.
The IAction parameter from run method from the interface is silently discarded and the another run method
with a selection parameter is called instead.
To aid man to deal with complexity and enormus details god permit man insight to the concept of
abstraction. To break OO contracts and force programmer to know literally every class because every class
has no connection to its "super" class is not only sin to programming style and the technical progress man
made in the the field of computer science since the days of crafting fullblown applications in assembler; it is also a sin against god himself and his glory. Is there anything left
I can say to get this programming "style" from hell out out your fucking brain??


---

Fuck a duck.
org.eclipse.jdt.core.eval.IEvaluationContext.IJavaProject

You want a unified view on everything in your package navigator ala everything is a IResource?
IJavaProject is not a IResource or a IProject as you might thing.

Whats wrong with IResource? Is a JavaProject not a IResource? In fact, isnt a JavaProject even an IProject? 

I see the patterns here. jdt tries very hard to give a programmer no clue whats going on.
You read in every book "everything is a resource in the navigator". So you depend on that
and get bite in the back. An IJavaProject has a getProject() method. So a project which returns
a project. Counterintuitive and easily avoidable by simply playing by the rules.
I suggest every jdt develeoper to read "Contributing to Eclipse" by Erich Gamma and Kent Beck.
They have some very clear rules for programming in eclipse.

---
JavaEditor.setPreferenceStore(...):

A ! is missing in the if-clause. Now a new JavaSourceViewerConf is instantiated even if it is there already.
The instantiation uses a deprecated constructor.


---
org.eclipse.jdt.internal.ui.javaeditor.SemanticHighlightingManager.install(...)
This class should not instantiate 


---
QA in action:
JavaEditor: private boolean fMarkLocalVariableypeOccurrences;



---
InternalJob.getState(...): Uses public constants from Job, one of its subclasses ! Isnt it said that a superclass
sould not know its subclasses?




