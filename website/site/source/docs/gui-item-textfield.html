<%define inDocumentationSection %>
<%define inDocumentationSection.gui %>
<%set title = J2ME Polish: TextField %>
<%set basedir = ../ %>
<%include start.txt %>

	<h1 id="top">TextField</h1>
	<ul class="relatedtechnologies">
		<li class="relatedtechnologiesheader">Related Topics:</li>
		<li><a href="gui-item-choicetextfield">ChoiceTextField</a></li>
		<li><a href="gui-item-stringitem.html">StringItem</a></li>
		<li><a href="gui-item-filteredchoicegroup">FilteredChoiceGroup</a></li>
		<li><a href="gui-screen-filteredlist">FilteredList</a></li>
		<li><a href="gui-concepts.html">GUI Concepts</a></li>
		<li><a href="gui-css-basics.html">CSS Basics</a></li>
	</ul>
	<%index %>
	<p>
	The TextField allows you to enter data in your application in different modes:
	</p>
	<ul>
		<li><b>Native Input Mode</b>: When the native mode  is activated, 
			a new input screen will pop up for the user and special input modes like T9 or handwriting recognition can be used. 
			This allows your user to use all native input mechanisms that the target device supports but it does interrupt
			the flow within the application. The Native Input Mode is used by default.
		</li>
		<li><b>Direct Input Mode</b>: With the Direct Input Mode J2ME Polish accepts input directly without showing a new popup screen. 
			Unless the device contains a full keyboard, the user
			has to press keys several times for accessing specific characters - for example press '2' twice for getting a 'b'.
		</li>
		<li><b>Predictive Input Mode</b>: Use the Predictive Input Mode for allowing your users to enter words conveniently - for
			example enter 'hello' by pressing '43556'.
		</li>
	</ul>
	<h2 id="Design">Design</h2>
	<p>
	Since J2ME Polish' TextFields internally extend <a href="gui-item-stringitem.html">StringItems</a> you can use any
	StringItem design settings as well, for example text-effects. 
	<br /><img src="<%= basedir%>images/gui-item-textfield2.png"  width="228" height="163" alt="A textfield in action" />
	</p>
	<p>
	The above TextField has been designed with following styles:
	</p>
<pre>
.itemTextInput {
	font-color: black;
	text-effect: smiley;
}
.itemTextInput:hover {
	background-color: #7196B7;
}
info {
	font-color: gray;
}
</pre>	
	<p>Additionally following settings have been made:
	</p>
<pre>
&lt;variable name=&quot;polish.TextField.useDirectInput&quot; value=&quot;true&quot;/&gt;
&lt;variable name=&quot;polish.TextField.usePredictiveInput&quot; value=&quot;true&quot;/&gt;
&lt;variable name=&quot;polish.TextField.includeInputInfo&quot; value=&quot;true&quot;/&gt;
&lt;variable name=&quot;smileys&quot; value=&quot;{new Smiley(new String[]{":-)",":)"},"/smiley_1.png","smile"),new Smiley(new String[]{":-P",":P"},"/smiley_2.png","cheekie"),new Smiley(new String[]{":-(",":("},"/smiley_3.png","ouch")}&quot;/&gt;
</pre>	
	<p>
	Specific design attributes:
	</p>
	<table class="borderedTable"  cellspacing="0" cellpadding="3" border="1">
	<tr><th>CSS Attribute&nbsp;&nbsp;</th><th>Default</th><th>Values</th><th>Applies To&nbsp;&nbsp;</th><th>Explanation</th></tr>
	<tr>
	 <td>textfield-direct-input</td>
	 <td>false</td>
	 <td>false, true</td>
	<td>TextField</td>
	 <td>Defines whether the direct input mode should be activated. By default the direct input mode is deactivated (&quot;false&quot;). 
	 	You can also activate the direct input mode globally for all TextFields and TextBoxes using the 
	 	<code>polish.TextField.useDirectInputMode</code> preprocessing variable (see below).
	 </td>
	</tr>
	<tr>
	 <td>textfield-caret-color</td>
	 <td>same as font-color</td>
	 <td>color definition</td>
	<td>TextField</td>
	 <td>The color of the caret which indicates the editing position. This defaults to the color of the used font.</td>
	</tr>
	<tr>
	 <td>textfield-show-length</td>
	 <td>false</td>
	 <td>false, true</td>
	<td>TextField</td>
	 <td>Determines whether the length of the entered text should be shown during the editing of this field. This has an effect only when the direct input mode is used.</td>
	</tr>	
	<tr>
		<td>textfield-caret-flash</td>
		<td>true</td>
		<td>true, false</td>
		<td>TextField</td>
		<td>Defines whether the current length of the input should be shown.</td>
	</tr>
	<!-- 
	<tr>
		<td></td><td></td><td></td><td></td>
		<td>
		</td>
	</tr>
	<tr>
		<td></td><td></td><td></td><td></td>
		<td>
<pre>
</pre>
		</td>
	</tr>
	<tr>
		<td></td><td></td><td></td><td></td>
		<td>
<pre>
</pre>
		</td>
		 -->
	</table>
	<p>
	The following example shows the use of the TextField attributes:
	</p>
<pre>
.itemInput {
	padding: 2;
	background-color: silver;
	border-color: gray;
	textfield-direct-input: true;
	textfield-caret-color: red;
	textfield-show-length: true;
}
.itemInput:hover {
	background-color: white;
	border-color: black;
}
</pre>

	<h2 id="textfield-commands">TextField-Commands</h2>
	<p>
	A TextField adds the &quot;Clear&quot; and &quot;Delete&quot; commands to the menu by default. 
	The names of these commands can be <a href="localization.html#localization-gui">changed easily</a>. 
	If you want to suppress the commands completely, the <code>polish.TextField.suppressCommands</code>-variable has to be set:
	</p>
<pre>
&lt;variable name=&quot;polish.TextField.suppressCommands&quot; value=&quot;true&quot;/&gt;
</pre>
	<p>You can also supress the &quot;Delete&quot; command only:
	</p>
<pre>
&lt;variable name=&quot;polish.TextField.suppressDeleteCommand&quot; value=&quot;true&quot;/&gt;
</pre>
	<p>When using the direct input mode and in case you allow the input of symbols, you can suppress the &quot;Add Symbol&quot;
	command as well:
	</p>
<pre>
&lt;variable name=&quot;polish.TextField.supportSymbolsEntry&quot; value=&quot;true&quot;/&gt;
&lt;variable name=&quot;polish.TextField.suppressAddSymbolCommand&quot; value=&quot;true&quot; if=&quot;polish.key.AddSymbolKey:defined&quot; /&gt;
</pre>
	<h2 id="textfield-DirectInputMode">Direct Input Mode</h2>
<p>
The direct input mode can be activated for TextFields as well as for TextBoxes using the CSS-attribute &quot;textfield-direct-input&quot; or by defining the preprocessing-variable &quot;polish.TextField.useDirectInput&quot; in the build.xml file:
</p>
<pre>
&lt;variable name=&quot;polish.TextField.useDirectInput&quot; value=&quot;true&quot;/&gt;
</pre>
<p>
When the direct input mode is used, no extra screen will be used for editing the text and all  designing possibilities of J2ME Polish can be used. When the TextField is used within a Form, the associated ItemStateListener will be notified after each change of the text.
</p>
<p>
On stylus-based devices, this mode should not be used since these devices often rely on native input methods like handwriting recognition. This can be ensured by setting the preprocessing variable only for devices which have no pointer-events:
</p>
<pre>
&lt;variable name=&quot;polish.TextField.useDirectInput&quot; value=&quot;true&quot; unless=&quot;polish.hasPointerEvents or isOS(Windows)&quot;/&gt;
</pre>
<p>
The direct input should not be used for editing longs texts (i.e. TextBoxes), since T9 and similar input helpers cannot be used in this mode.
</p>
<h3 id="textfield-info">The Input Mode Information Indicator</h3>
<p>
The user can change the input mode from lowercase (&quot;abc&quot;), to initial-letter uppercase (&quot;Abc&quot;),
  to uppercase (&quot;ABC&quot;) and to numeric (&quot;123&quot;). 
  The current input mode is shown below the title in an extra StringItem. 
  This item can be designed using the predefined CSS-style &quot;info&quot;:
</p>
<pre>
info {
	padding-right: 10;
	background: none;
	border-color: black;
	font-style: plain; 
	font-face: proportional; 
	font-size: small; 
	font-color: fontColor; /* a color defined in the &quot;colors&quot; section */
	layout: right;
}
</pre>
<p>You can include the info item in the TextField instead of showing it at the top of the screen by specifying 
<code>polish.TextField.includeInputInfo</code> in your <i>build.xml</i> script:
</p>
<pre>
&lt;variable name=&quot;polish.TextField.includeInputInfo&quot; value=&quot;true&quot; /&gt;
</pre>
<p>
The info item can be deactivated globally by setting the &quot;polish.TextField.showInputInfo&quot; variable to &quot;false&quot;:
</p>
<pre>
&lt;variable name=&quot;polish.TextField.showInputInfo&quot; value=&quot;false&quot; /&gt;
</pre>
<p>
Next to using the CSS-attributes &quot;textfield-caret-color&quot; and &quot;textfield-show-length&quot; 
you can adjust the behavior of the direct input mode with several preprocessing variables. 
</p>
<h3 id="textfield-symbols">Adding Symbols in the TextField</h3>
<p>
The user can also add special symbols into a TextField, when the <code>polish.TextField.supportSymbolsEntry</code> preprocessing
variable is set to <code>true</code>:
</p>
<pre>
&lt;variable name=&quot;polish.TextField.supportSymbolsEntry&quot; value=&quot;true&quot; /&gt;
</pre>
<p>You can define your own set of symbols by defining the variable <code>polish.TextField.Symbols</code>.
</p>

	<h2 id="textfield-PredictiveInputMode">Predictive Input Mode</h2>
	<p>
	The predictive input mode can be activated by setting the variable <code>polish.TextField.usePredictiveInput</code> to true.
	<br/>
	NOTE : The predictive input mode is not available for BlackBerry.
	</p>
<pre>
&lt;variable name=&quot;polish.TextField.usePredictiveInput&quot; value=&quot;true&quot; /&gt;
</pre>

	<h3>Installation</h3>
	
	<p>
	To use the predictive input in the application, the dictionary must be installed first. To do this,
	please select "Install Predictive" from the menu of the application using predictive input:
	</p>
	
	<img src="predictive.install.jpg"></img> 
	
	<p>
	There are two different installation modes depending on the device using the application: 
	</p>
	<li>
	The first mode installs the dictionary in a shared record store for all applications to use the same unique dictionary.
	This mode is available to most of the devices supporting MIDP2 (exceptions are listed in the second mode).
	The dictionary is contained within a setup that will be downloaded and installed as an j2me application to the
	user's device. The user just needs to follow the instructions. (NOTE : Some devices will download the application
	but will not automatically launch the setup. In this case, just start the setup manually)
	</li>
	
	<p>
	<img src="predictive.install.jpg"></img> 
	</p>
	
	<li>
	The second mode is used for devices that need signing or are just not capable to use a shared record store.
	These devices include all MIDP1 and Motorola devices.
	In this case, the dictionary is downloaded directly to the application without a setup and installed in a local record store. 
	Every application using the predictive mode has to install its own dictionary.
	</li>
	
	<p>
	<img src="predictive.install.jpg"></img> 
	</p>
	
	<h3>Usage</h3>
	
	<p>
	After the installation of the dictionary has finished, the predictive mode can be used.
	The user just types the numbers equivalent to the letters of the word he would like to see in the textfield.
	For each typed number the predictive mode will display the words suitable. For example, the combination
	668437 will return the results "mother" and "videos" to choose from:
	</p>
	
	<p>
	<img src="predictive.install.jpg"></img> 
	</p>
	
	<p>
	To choose one of the possibilities, just press UP and select the desired word by pressing FIRE. The dictionary
	remembers the most used selected words and resorts the list the next time the results are shown. For example, if 
	you choose "videos" in the example above, the next time you type 668437 "videos" will be the first option.
	</p>
	
	<p>
	The user can choose different input modes the enter the words, like "abc", "ABC" ... To indicate the predictive
	mode a double arrow is heading the input mode in the info box:
	</p>
	
	<p>
	To disable and enable the predictive input of a single textfield, the commands "Disable Predicitive Input" and 
	"Enable Predicitive Input" can be used. The user can also add new words to the dictionary be using the "Add Word" command in the menu. The added words
	will be available in all applications using the predictive input unless the 
	second installation mode was used (see above).
	</p>
	
	<p>
	
	</p>
	
	<p>
	<img src="predictive.install.jpg"></img> 
	</p>
	
	<h3>Styling</h3>
	
	<p>
	There are predefined styles to design the list of your predictive results to set in the CSS style of the textfield. 
	If a style is missing the default will be used:
	</p>
	
	<table class="borderedTable"  cellspacing="0" cellpadding="3" border="1">
	<tr><th>CSS Attribute&nbsp;&nbsp;</th><th>Explanation</th></tr>
	<tr>
	 <td>predictive-containerstyle</td>
	 <td>Points to a style to design the list of predictive results itself.
	 </td>
	</tr>
	<tr>
	 <td>predictive-choicestyle</td>
	 <td>Points to a style to design the entry in a list of predictive results.
	 </td>
	</tr>
	<tr>
	 <td>predictive-choice-orientation</td>
	 <td>Sets the orientation of the list of predictive results. Two values are permitted: "top" and "bottom".
	 The default is "bottom" which draw the list in an descending order below the textfield. "top" draws
	 the list in an ascending order above the textfield. This can be useful for textfields that 
	 don't provide enough space below them to display the list.
	 </td>
	</tr>
	</table>
	
	<p>
	Here's an example how to style a predictive textfield:
	</p>
	
	<pre>
.myTextfield {
	font-color: blue;
	font-size: small;
	predictive-containerstyle: myTextFieldContainer;
	predictive-choicestyle:	myTextFieldChoice;
	predictive-choicestyle: top;	
}
	</pre>

	<pre>
.myTextFieldContainer {
	border-color: blue;
	border-size: 1;
}
	</pre>
	
	<pre>
.myTextfieldChoice {
	font-color: blue;
	font-size: small;
	font-style: bold;
}
	</pre>	
	
	<h3>Array mode</h3>
	
	<p>
	Rather than using the dictionary the predictive input can be used with a simple array of words. These words
	are checked if they match the predictive input of the user and the matches are returned with a method call.
	</p>
	
	<p>
	To initialize the array mode, the method <code>setPredictiveDictionary(TextField field, String[] words)</code>
	of <code>UIAccess</code> must be called. The method takes two arguments : the array of <code>String</code> objects
	and the textfield that should be used to provide the input to filter strings. A call with <code>null</code> as the array
	resets the source for the given textfield to the dictionary.
	</p>
	
	<pre>
	TextField myField = new TextField("title","content",100,TextField.ANY);

	String[] cities = new String[5];

	cities[0] = "Amsterdam";
	cities[1] = "Bombay";
	cities[2] = "Bremen";
	cities[3] = "Paris";
	cities[4] = "New York";
	
	UIAccess.setPredictiveDictionary(myField,cities);</pre>
	
	<p>
	If the user enters a sequence of numbers (similar to the normal dictionary mode) the predictive input mode internally
	filters out the strings that don't match. To obtain the results the method <code>getResults()</code> of the
	<code>PredicitveAccess</code> object inside the textfield must be called which returns an <code>ArrayList</code> of strings. 
	</p>
	
	<pre>
	ArrayList results = mytextfield.getPredictiveAccess().getResults();</pre>
	
	<p>
	The method to obtain the results is usually called in the <code>itemStateChanged()</code> callback of the interface 
	<code>ItemStateListener</code> so that everytime the user enters a number the results are obtained and processed.
	The source set of strings for the array mode can be changed everytime by calling 
	<code>setPredictiveDictionary(TextField field, String[] words)</code>.
	</p>
	
	<h2 id="textfield-Programming">Programming</h2>
	<p>
	You can use 
	<a href="<%= javadocdir %>/javadoc/j2me/de/enough/polish/ui/UiAccess.html">UiAccess</a> for accessing J2ME Polish specific 
	functionalities of the TextField:
	</p>
	
	<ul>
		<li><code>UiAccess.setCaretPosition( TextField field, int position )</code>: sets the position of the input caret</li>
		<li><code>UiAccess.setInputMode( javax.microedition.lcdui.TextField field, int inputMode )</code>: Sets the input mode : either 
			<code>UiAccess.MODE_NUMBERS</code>, <code>UiAccess.MODE_LOWERCASE</code>, <code>UiAccess.MODE_UPPERCASE</code>, 
			<code>UiAccess.MODE_FIRST_UPPERCASE</code>,  or <code>UiAccess.MODE_NATIVE</code>.
		</li>
		<li><code>int UiAccess.getInputMode( TextField field )</code>: Gets the current input mode.</li>
		<li><code>String UiAccess.getDotSeparatedDecimalString( TextField field )</code>: Retrieves the 
			contents of a DECIMAL TextField as a number with floating numbers separated by a dot, no matter what locale is being used.
		</li>
		<li><code>UiAccess.setPredictiveDictionary(TextField field, String[] words)</code>: Allows the user only to enter any 
			of the given words - can only be used when the predictive mode has been anabled.
		</li>
		<li><code>UiAccess.setTextfieldHelp(TextField field, String text)</code>: Sets the helper text that is being shown 
			when the text of a TextField is empty - can only be used when <code>polish.TextField.showHelp</code> is <code>true</code>.
		</li>
		<li><code>UiAccess.setTextfieldInfo(TextField field, String info)</code>: 
			Sets the strings that should be displayed to guide the user what to do with the textfield (like "type text here").
			A value of <code>null</code> shows no info in the field.
		</li>
		<li><code>UiAccess.setSuppressCommands(TextField field, boolean suppress)</code>: Suppresses the textfields standard 
		and predictive commands like Clear, Add Word etc.
		</li>
		<li><code>UiAccess.setWordNotFound(TextField field, Alert alert)</code>: 
		Sets an custom alert to show the "Word not found" message of the predictive input.
		</li>
		
		<!-- 
		<li><code>UiAccess.</code>: </li>
		<li><code>UiAccess.</code>: </li>
		<li><code>UiAccess.</code>: </li>
		<li><code>UiAccess.</code>: </li>
		<li><code>UiAccess.</code>: </li>
		 -->
	</ul>
	<h2 id="textfield-Configuration">Configuration</h2>
	<p>As explained in the above sections, following configurations can be done within the &lt;variables&gt; variables section
	of your build.xml script:
	</p>
<table class="borderedTable"  cellspacing="0" cellpadding="3" border="1">
	<tr><th>Variable&nbsp;&nbsp;</th><th>Default&nbsp;&nbsp;</th><th>Explanation</th></tr>
	<tr>
	 <td>polish.command.clear</td>
	 <td>Clear</td>
	 <td>Command text for deleting the complete text.</td>
	</tr>
	<tr>
	 <td>polish.command.clear.priority</td>
	 <td>8</td>
	 <td>Priority of the clear command.</td>
	</tr>
	<tr>
	 <td>polish.command.delete</td>
	 <td>Delete</td>
	 <td>Command text for deleting a single character.</td>
	</tr>
	<tr>
	 <td>polish.command.delete.priority</td>
	 <td>1</td>
	 <td>Priority of the delete command.</td>
	</tr>
	<tr>
	 <td>polish.command.entersymbol</td>
	 <td>Add Symbol</td>
	 <td>Command text for adding symbols, only applicable when <code>polish.TextField.supportSymbolsEntry</code> is <code>true</code>.</td>
	</tr>
	<tr>
	 <td>polish.command.entersymbol.priority</td>
	 <td>9</td>
	 <td>Priority of the command for adding symbols.</td>
	</tr>
	<tr>
	 <td>polish.key.AddSymbolKey, polish.key.AddSymbolKey2</td>
	 <td>Device dependent</td>
	 <td>Device key that triggers the symbols entry screen when pressed longer.</td>
	</tr>
	<tr>
	 <td>polish.key.backspace</td>
	 <td>Device dependent</td>
	 <td>Alternativ key for deleting a character.</td>
	</tr>
	<tr>
	 <td>polish.key.ChangeInputModeKey</td>
	 <td>Device dependent</td>
	 <td>The key which is used for changing the input mode between lowercase (&quot;abc&quot;), uppercase (&quot;ABC&quot;), initial-letter uppercase (&quot;Abc&quot;) and numeric (&quot;123&quot;). On Sony-Ericsson devices Canvas.KEY_STAR (42), on Motorola devices Canvas.KEY_NUM0 (48) and on all other devices Canvas.KEY_POUND (35) is used.</td>
	</tr>
	<tr>
	 <td>polish.key.ChangeNumericalAlphaInputModeKey</td>
	 <td>Device dependent</td>
	 <td>Device key for switching between numerical and alphabet input, usually only used on Motorola handsets.</td>
	</tr>
	<tr>
	 <td>polish.key.ClearKey</td>
	 <td>Device dependent</td>
	 <td>Device key for deleting a character, it is often -8.</td>
	</tr>
	<tr>
	 <td>polish.key.enter</td>
	 <td>Device dependent</td>
	 <td>Device key for entering new lines.</td>
	</tr>
	<tr>
	 <td>polish.key.shift</td>
	 <td>Device dependent</td>
	 <td>Device key for entering upper case character.</td>
	</tr>
	<tr>
	 <td>polish.key.supportsAsciiKeyMap</td>
	 <td>Device dependent</td>
	 <td>If true the user can use a keyboard for entering characters.</td>
	</tr>
	<!-- 
	<tr>
	 <td></td>
	 <td></td>
	 <td>.</td>
	</tr>
	 -->
	<tr>
	 <td>polish.TextField.allowNativeModeSwitch</td>
	 <td>false</td>
	 <td>Allows to switch back to the native mode when the <code>polish.TextField.useDirectInput</code> is being used.</td>
	</tr>
	
	<tr>
	 <td>polish.TextField.charactersKey1</td>
	 <td>&quot;.,!?:/@_-+1&quot;</td>
	 <td>The characters which are available when the key &quot;1&quot; is pressed.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey2</td>
	 <td>&quot;abc2&quot;</td>
	 <td>The characters which are available when the key &quot;2&quot; is pressed. It might be useful to add local specific umlauts here.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey3</td>
	 <td>&quot;def3&quot;</td>
	 <td>The characters which are available when the key &quot;3&quot; is pressed.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey4</td>
	 <td>&quot;ghi4&quot;</td>
	 <td>The characters which are available when the key &quot;4&quot; is pressed.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey5</td>
	 <td>&quot;jkl5&quot;</td>
	 <td>The characters which are available when the key &quot;5&quot; is pressed.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey6</td>
	 <td>&quot;mno6&quot;</td>
	 <td>The characters which are available when the key &quot;6&quot; is pressed.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey7</td>
	 <td>&quot;pqrs7&quot;</td>
	 <td>The characters which are available when the key &quot;7&quot; is pressed.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey8</td>
	 <td>&quot;tuv8&quot;</td>
	 <td>The characters which are available when the key &quot;8&quot; is pressed.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey9</td>
	 <td>&quot;wxyz9&quot;</td>
	 <td>The characters which are available when the key &quot;9&quot; is pressed.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKey0</td>
	 <td>&quot; 0&quot;</td>
	 <td>The characters which are available when the key &quot;0&quot; is pressed. On Motorola devices this key is used for switching the input mode.</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKeyStar</td>
	 <td>&quot;.,!?:/@_-+&quot;</td>
	 <td>The characters which are available when the key &quot;*&quot; is pressed. On Motorola devices this key is used for entering spaces (&quot; &quot;).</td>
	</tr>
	<tr>
	 <td>polish.TextField.charactersKeyPound</td>
	 <td>(none)</td>
	 <td>The characters which are available when the key &quot;#&quot; is pressed. On Sony-Ericsson devices this key is used for entering spaces (&quot; &quot;).</td>
	</tr>
	<tr>
	 <td>polish.TextField.help</td>
	 <td>type text here</td>
	 <td>Text that is being shown when the TextField is empty - the <code>polish.TextField.showHelpText</code> variable needs to be set as well.</td>
	</tr>
	<tr>
	 <td>polish.TextField.includeInputInfo</td>
	 <td>false</td>
	 <td>Includes the input mode indicator into the TextField instead of showing it at the top of the screen, only applicable when the <code>polish.TextField.useDirectInput</code> is active.</td>
	</tr>
	<tr>
	 <td>polish.TextField.InputTimeout</td>
	 <td>&quot;1000&quot;</td>
	 <td>The timeout in milliseconds after which a chosen character is inserted into the text automatically.</td>
	</tr>
	<tr>
	 <td>polish.TextField.showInputInfo</td>
	 <td>&quot;true&quot;</td>
	 <td>Defines whether the box showing the current input mode (e.g. &quot;123&quot;, &quot;Abc&quot;, &quot;abc&quot;, &quot;ABC&quot;) should be shown at all. You can deactivate the box globally by setting the &quot;polish.TextField.showInputInfo&quot; variable to &quot;false&quot;.</td>
	</tr>
	<tr>
	 <td>polish.TextField.suppressAddSymbolCommand</td>
	 <td>false</td>
	 <td>Surpresses the command for adding symbols when <code>polish.TextField.supportSymbolsEntry</code> is <code>true</code>.</td>
	</tr>
	<tr>
	 <td>polish.TextField.suppressAutoInputModeChange</td>
	 <td>false</td>
	 <td>If <code>true</code> the TextField will not change the input mode automatically, e.g. after the user enters a dot (in that case the TextField switches into the 'Abc' mode by default.</td>
	</tr>
	<tr>
	 <td>polish.TextField.suppressCommands</td>
	 <td>false</td>
	 <td>Deactivates all TextField commands.</td>
	</tr>
	<tr>
	 <td>polish.TextField.suppressDeleteCommand</td>
	 <td>false</td>
	 <td>Deactivates the &quot;Delete&quot; command of a TextField.</td>
	</tr>
	<tr>
	 <td>polish.TextField.supportSymbolsEntry</td>
	 <td>false</td>
	 <td>Allows users to enter special symbols from within a TextField, only applicable when the direct input mode is activated using <code>polish.TextField.useDirectInput</code>.</td>
	</tr>
	<tr>
	 <td>polish.TextField.Symbols</td>
	 <td>&amp;@/\&lt;&gt;(){}[].,+-*:_\#$%</td>
	 <td>A string with of symbols that the user can select when symbol entry has been activated using <code>polish.TextField.supportSymbolsEntry</code>.</td>
	</tr>
	<tr>
	 <td>polish.TextField.showHelpText</td>
	 <td>false</td>
	 <td>Displays a text for empty TextFields - defaults to &quot;type text here&quot;.</td>
	</tr>
	<tr>
	 <td>polish.TextField.useDirectInput</td>
	 <td>false</td>
	 <td>Activates the direct input mode.</td>
	</tr>
	<tr>
	 <td>polish.TextField.usePredictiveInput</td>
	 <td>false</td>
	 <td>Enables the predictive input mode, the <code>polish.TextField.useDirectInput</code> mode needs to be active, too.</td>
	</tr>
	<!-- 
	
	<tr>
	 <td></td>
	 <td>false</td>
	 <td>.</td>
	</tr>
	<tr>
	 <td></td>
	 <td>false</td>
	 <td>.</td>
	</tr>
	 -->
</table>	
	<h2 id="textfield-JavaDoc">JavaDoc</h2>
	<p>
		<a href="<%= javadocdir %>/javadoc/j2me/de/enough/polish/ui/TextField.html">TextField</a>.
		<a href="<%= javadocdir %>/javadoc/j2me/de/enough/polish/ui/UiAccess.html">UiAccess</a>.
	</p>

<%include end.txt %>

